<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>清晨迷雾</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="keywords" content="">
	<meta name="generator" content="清晨迷雾">

	<!-- Fav and touch icons -->
	<link rel="shortcut icon" href="favicon.ico">

	<!-- Custom CSS -->
	<link rel="stylesheet" href="css/pixyll.css" type="text/css">

	<!-- Fonts -->
	<link href='//fonts.useso.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
	<link href='//fonts.useso.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
	<link rel="stylesheet" href="css/highlight/default.css">
	<script src="js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head><body class="">
  <div class="site-wrap">
<header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="" class="site-title">清晨迷雾de小站</a>

      <nav class="site-nav right">
<a href="index.html">首页</a>
<a href="about.html">关于</a>
<a href="feed.xml">订阅</a>
      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
		<div class="home">
		  <div class="posts">
					<div class="post">
						<a href="blog/2015-03-04-java-AES-compatible.html" class="post-link">
						  <h3 class="h2 post-title">Java中AES加密兼容PHP等其他语言实现</h3>
						  <p class="post-meta">2015年03月04日</p>
						</a>
						<p class="post-summary"><p>在之前的项目中涉及到java和php通信时采用AES加密，但是因为一些算法差异，导致不能直接通信，java需要做补位操作才能实现，后换了一种算法协议。今天在整理加密算法时，发现可以通过补位的方式来达到和PHP的通信，具体实现参照了 <a href="http://www.cnblogs.com/AloneSword/p/3485912.html">AES加密CBC模式兼容互通四种编程语言平台</a>.</p><p>两种语言的差别主要是对于内容的填充实现上不一致.</p><p>AES支持五中模式：CBC，CFB，ECB，OFB，PCBC；支持三种填充：NoPadding，PKCS5Padding，ISO10126Padding。不支持SSL3Padding。不支持“NONE”模式。<br/>其中AES/ECB/NoPadding和我现在使用的AESUtil得出的结果相同(在16的整数倍情况下)。<br/>不带模式和填充来获取AES算法的时候，其默认使用ECB/PKCS5Padding。</p>
<pre><code>算法/模式/填充                16字节加密后数据长度        不满16字节加密后长度
AES/CBC/NoPadding             16                          不支持
AES/CBC/PKCS5Padding          32                          16
AES/CBC/ISO10126Padding       32                          16
AES/CFB/NoPadding             16                          原始数据长度
AES/CFB/PKCS5Padding          32                          16
AES/CFB/ISO10126Padding       32                          16
AES/ECB/NoPadding             16                          不支持
AES/ECB/PKCS5Padding          32                          16
AES/ECB/ISO10126Padding       32                          16
AES/OFB/NoPadding             16                          原始数据长度
AES/OFB/PKCS5Padding          32                          16
AES/OFB/ISO10126Padding       32                          16
AES/PCBC/NoPadding            16                          不支持
AES/PCBC/PKCS5Padding         32                          16
AES/PCBC/ISO10126Padding      32                          16
</code></pre><p>可以看到，在原始数据长度为16的整数倍时，假如原始数据长度等于16*n，则使用NoPadding时加密后数据长度等于16*n，其它情况下加密数据长度等于16*(n+1)。在不足16的整数倍的情况下，假如原始数据长度等于16*n+m[其中m小于16]，除了NoPadding填充之外的任何方式，加密数据长度都等于16*(n+1)；NoPadding填充情况下，CBC、ECB和PCBC三种模式是不支持的，CFB、OFB两种模式下则加密数据长度等于原始数据长度。</p><p>我的主要实现思路是对于密码和IV我们通过MD5算法强制让所得到的byte[]长度是16的倍数，对于要加密的内容，先获取长度，如果长度不是16的倍数，则申请大于现有长度而且是16倍数的byte[]内存，然后通过拷贝把原有的内容拷贝到新申请的内存空间，这就相当于做了补零操作。其实就是实现了java的AES/CBC/ZeroPadding算法;对于解密也一样需要对末端的补零位清理，达到加密和解密的值相等；具体实现代码下面给出参考实现。</p><p>java参考代码：</p>
<pre><code class="java">/**
 * 兼容PHP等其他语言AES加密、解密方法
 *
 * @param mode
 * @param data
 * @param password
 * @param iv
 * @return
 * @throws Exception
 */
public static byte[] aesZeroPadding(int mode, byte[] data, String password, String iv) throws Exception {
	SecretKeySpec secretKeySpec = new SecretKeySpec(
		StringUtils.getBytesUtf8(md5(password).substring(0, 16)), 
		&quot;AES&quot;);
	Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);

	IvParameterSpec ivParameterSpec = new IvParameterSpec(
		StringUtils.getBytesUtf8(md5(iv).substring(0, 16)));
	cipher.init(mode, secretKeySpec, ivParameterSpec);

	return cipher.doFinal(data);
}

/**
 * 兼容PHP等其他语言AES加密方法
 *
 * @param data
 * @param password
 * @param iv
 * @return
 * @throws Exception
 */
public static String encodeAESZeroPadding(String data, String password, String iv) {
	try {
		Cipher cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);
		//对内容不是16整数倍数时补位
		int blockSize = cipher.getBlockSize();
		byte[] bytes = StringUtils.getBytesUtf8(data);
		int dataBytesLength = bytes.length;
		int mod = dataBytesLength % blockSize;
		if (mod != 0) {
			dataBytesLength = dataBytesLength + (blockSize - mod);
		}
		byte[] newBytes = new byte[dataBytesLength];
		System.arraycopy(bytes, 0, newBytes, 0, bytes.length);
		return Base64.encode(aesZeroPadding(Cipher.ENCRYPT_MODE, newBytes, password, iv));
	} catch (Exception e) {
		logger.error(&quot;AES ZeroPadding模式加密失败&quot;, e);
		throw new RuntimeException(e);
	}
}

/**
 * 兼容PHP等其他语言AES解密方法
 *
 * @param data
 * @param password
 * @param iv
 * @return
 * @throws Exception
 */
public static String decodeAESZeroPadding(String data, String password, String iv) {
	try {
		byte[] decodedBytes = aesZeroPadding(
			Cipher.DECRYPT_MODE, Base64.decode(data), password, iv);
		//去除增加的zero padding
		int emptyLength = 0;
		for (int i = decodedBytes.length; i &gt; 0; i--) {

			if (decodedBytes[i - 1] == 0) {
				emptyLength++;
			} else {
				break;
			}
		}
		byte[] newBytes = new byte[decodedBytes.length - emptyLength];
		System.arraycopy(decodedBytes, 0, newBytes, 0, decodedBytes.length - emptyLength);
		return StringUtils.newStringUtf8(newBytes);
	} catch (Exception e) {
		logger.error(&quot;AES ZeroPadding模式解密失败&quot;, e);
		throw new RuntimeException(e);
	}
}
</code></pre><p>php参考代码：</p>
<pre><code class="php">//加密
$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $privateKey, $data, MCRYPT_MODE_CBC, $iv);
echo(base64_encode($encrypted));
echo &#39;&lt;br/&gt;&#39;; 

//解密
$encryptedData = base64_decode($encrypted);
$decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $privateKey, $encryptedData, MCRYPT_MODE_CBC, $iv);
echo($decrypted);
</code></pre></p>
					 </div>
					<div class="post">
						<a href="blog/2015-03-03-maven-faq.html" class="post-link">
						  <h3 class="h2 post-title">Maven使用常见问题</h3>
						  <p class="post-meta">2015年03月03日</p>
						</a>
						<p class="post-summary"><ol>
  <li><p><strong>maven打包时不执行测试用例？</strong></p><p>有时因为测试不能运行,或者为了更快的编译,希望用mvn package的时候跳过test,有如下两种方法：<br/>第一种方法:</p>
  <pre><code>mvn -DskipTests clean package
</code></pre><p>第二种方法</p>
  <pre><code>mvn -Dmaven.test.skip=true clean package
</code></pre><p>但是这两个命令是有区别的，一定要注意。参数-DskipTests和-Dmaven.test.skip=true，这两个参数的主要区别是：</p>
  <ul>
    <li>-DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。</li>
    <li>-Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。</li>
  </ul><p>如果在pom.xml设置了跳过，用命令即使设置跳过也不能覆盖，所以要清理掉xml中配置的<code>&lt;skipTests&gt;false&lt;/skipTests&gt;</code>:</p>
  <pre><code>&lt;plugin&gt;
	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
	&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
	&lt;version&gt;2.10&lt;/version&gt;
	&lt;configuration&gt;
		&lt;skipTests&gt;false&lt;/skipTests&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre></li>
  <li><p><strong>如何手动上传打好的jar包到nexus仓库？</strong></p><p>如果想人工通过mvn命令上传已经存在的jar包到nexus上，执行maven命令如下：</p>
  <pre><code>	mvn deploy:deploy-file 
	-Durl=http://{ip}:{port}/nexus/content/repositories/{repository-id} 
	-Dfile=./target/{jar-name}.jar 
	-DrepositoryId={repository-id}  
	-DgroupId={group-id} 
	-DartifactId={artifact-id} 
	-Dversion={version} 
	-Dpackaging=jar
</code></pre></li>
  <li><p><strong>如何强制每次编译时都从仓库取最新的依赖jar包？</strong></p><p>在执行命令时添加-U参数来强制从仓库取最新的jar包依赖，形如下面的命令：</p>
  <pre><code>mvn -U clean package
</code></pre></li>
  <li><p><strong>maven项目模块循环依赖如何解决？</strong></p><p>对于项目因为配置了循环依赖的maven工程，可以通过设定不同的artifactId来达到断掉依赖，从而保证项目能正确编译打包，就涉及到手动上传打好的jar包，并且修改artifactId上传到nexus仓库,手动上传参见第2点。</p></li>
</ol></p>
					 </div>
					<div class="post">
						<a href="blog/2015-03-02-about-j2ee-architecture.html" class="post-link">
						  <h3 class="h2 post-title">对于J2EE架构以及开发流程的一些感想</h3>
						  <p class="post-meta">2015年03月02日</p>
						</a>
						<p class="post-summary"><p>工作好久，也接触过不同架构和框架，多少有些感触，总结一下如下：</p>
<ul>
  <li>开发阶段，能够让开发人员快速上手，不能有太高的学习成本，最好是常用的Struts，spring，mybatis，hibernate等常用开源框架。提倡不要重复造轮子，最理想情况是升级改造！</li>
  <li>开发工具能够支持代码规范的自动检查，报错。</li>
  <li>有持续集成环境不断验证服务，必须有测试用例验证，并且验证代码是否符合规范，不符合规范报错，另外还要做代码覆盖率，注释检查等。做到错误提前发现</li>
  <li>功能交付前要有代码review</li>
  <li>测试以及交付阶段产生的功能需求必须跟踪</li>
  <li>开发过程中遇到的问题和解决方案要沉淀，文档必须迭代。发挥文档应有的功能价值。</li>
  <li>开发完成后，产品发布时自动发布成分布式或者集群式。开发不用关心如何部署。</li>
  <li>架构要支持HA，支持故障迁移，支持动态可伸缩</li>
  <li>产品交付阶段能够实时了解运行情况，监视实时动态，包含服务健康以及服务负载等指标，最好是图形化展示</li>
  <li>对于不同的项目一定要有协同看板，让团队知道团队的总体目标，让团队成员明确自己的任务，一个任务要具体人员，以及交付时间，以及交付产物有哪些!并且这些产物都是可以验证和review的。在一个固定的周期内要评审回顾。建议以敏捷的方式操作</li>
  <li>对于项目或者产品研发一定要明确不同角色的具体的流程，流程一定要管控死，流程可以根据迭代情况不断调整，但是调整前必须严格执行。否则就会有破窗效应，影响后续计划的执行，降低流程的执行效率。对于流程中的问题一定要及时弥补和反应，否则也会引起不好的后果。</li>
  <li>测试要自动化，部署自动化，运维要自动化，尽量减少人工干预，人可以在所有流程环节中，可以设置为最不可信任节点，有可以机器代替的尽量机器执行，做到高度自动化，高度可靠，高度量化！</li>
</ul></p>
					 </div>
					<div class="post">
						<a href="blog/2015-03-01-caijing.html" class="post-link">
						  <h3 class="h2 post-title">穹顶之下 同呼吸共命运</h3>
						  <p class="post-meta">2015年03月01日</p>
						</a>
						<p class="post-summary"><p>今天放假，乘着小孩睡觉的时间看了“柴静雾霾调查:穹顶之下 同呼吸共命运”。感触很深，问题发生了，怎么解决才是重中之重。</p><p>希望我家旁边的河流流淌的不再是黑水、臭水，而是中间游着鱼儿，可以垂钓的净水。希望政府可以多做点事情，让家园更加美好，让世界更加美好！愿你我生活的世界都是美好的。</p><h1>发现污染记得拨打12369.这个也许是我们举手之劳。</h1><p><iframe height=498 width=510 src="http://player.youku.com/embed/XOTAxMzQ1NzY0" frameborder=0 allowfullscreen></iframe></p></p>
					 </div>
					<div class="post">
						<a href="blog/2015-03-01-how-to-create-github-blog.html" class="post-link">
						  <h3 class="h2 post-title">怎样建立自己的Github博客</h3>
						  <p class="post-meta">2015年03月01日</p>
						</a>
						<p class="post-summary"><p>去年发生太多的事情，一直无时间打理博客，之前wordpress也荒废了。今年下决定好好的维护一个博客，记录一下自己的生活和学习。</p><p>在学习如何搭建一个github博客之前，首先我们需要了解github的博客本质是什么，我们都知道github的页面都是通过markdown语法编写的。其实github也支持普通的静态html页面显示，就类似于给你一个免费的HTML空间，你自己上传HTML页面和资源文件，这样就是一个网站，这个和我们普通理解的CMS或者Blog系统不太一样。现在Github推荐的jekyll本质就是提供一套主题给你，然后你自己运行本地的生成静态的脚本把.md结尾的文件按照模板生成静态HTML然后再发布到github的仓库中，github然后就可以对外展示你最新的东西了。所以我们的目的只有一个就是如何搭建一个静态HTML站点.</p><p>如何搭建一个github博客就变成如何搭建一个静态的HTML站点，那我们就不一定需要jekyll去做这件事，同样我们也可以使用纯静态HTML的空间或者PHP空间来作为我们的服务器空间。我们比较熟悉java变成，希望用自己熟悉和擅长东西来做这件事情，经过查找研究选择了<a href="http://jbake.org/">jbake</a>来做这件事。</p>
<ul>
  <li>在操作之前我们首先要有github的账号，具体如何申请一个博客空间请参照：<a href="https://help.github.com/articles/creating-pages-with-the-automatic-generator/">Creating Pages with the automatic generator</a>，</li>
  <li>有了空间如何绑定域名请参照：<a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/">Setting up a custom domain with GitHub Pages</a></li>
</ul><p>这样我们就有个一个github博客空间，并且可以通过域名访问了，下面就开始如何开始使用jbake搭建我们的博客系统，jbake使用freemarker模板引擎实现。具体的jbake如何运行和使用请参照：<a href="http://jbake.org/docs/2.3.2/">jbake使用手册</a>。因为jbake不支持首页分页，我对官方源码修改了下支持首页分页，如果需要请参见我的github：https://github.com/vouov/jbake，打好的支持分页的jar包可以直接下载替换，请下载：<a href="/uploads/software/jbake-core.jar">jbake-core.jar</a>,具体使用分页请参照我的blog源码：<a href="https://github.com/vouov/blog">github blog</a></p><p>使用jbake作为github的具体步骤如下（前提是我认为你已经申请号github博客空间，并且可以域名访问了）:</p>
<ul>
  <li>在你电脑创建一个blog目录，运行命令 jbake -i, 这样就会生成一个example博客模板，有JS、CSS、Images、freemarker模板等资源文件。</li>
  <li>运行命令 jbake . &lt;目的路径&gt;, 把当前的blog内容生成静态HTML到'目的路径'，便于发布展示。</li>
  <li>运行命令 jbake -s &lt;目的路径&gt;， 打开浏览器，输入URL地址：http://localhost:8820/,就可以看到示例博客的内容了。这个是一个bootstrap主题博客样式.</li>
  <li>如果不喜欢官方的主题，自己可以开发。我修改后的主题可以参照我的blog源码：<a href="https://github.com/vouov/blog">github blog</a></li>
  <li>接下来就是在blog目录中content\blog目录下写自己的.md文件，具体请参照markdown语法</li>
  <li>写好文章就是编译成HTML，运行命令 jbake . &lt;目的路径&gt;,刷新一下浏览器的地址就可以看到你的文章了</li>
  <li>提交同步自己的github仓库中，就可以通过域名访问最新的内容了</li>
</ul><p>用到的软件列表如下：<br/><a href="http://jbake.org">Jbake</a><br/><a href="https://highlightjs.org/">highlightjs</a><br/><a href="http://open.weibo.com/widget/comments.php">新浪微博留言箱</a><br/><a href="http://share.baidu.com/">百度分享</a></p><p>如果使用中有什么问题可以留言给我，或者通过最底部的多种联系方式联系我！<br/>具体可以参照我的github blog源码：<br/><a href="https://github.com/vouov/blog">blog jbake源码</a><br/><a href="https://github.com/vouov/vouov.github.io">编译后的blog HTML</a></p></p>
					 </div>
		  </div>
<div class="pagination clearfix mb1 mt4">
  <div class="left">
	        <a class="pagination-item" href="index.html">上一页</a>
  </div>
  <div class="right">
      <a class="pagination-item" href="3_index.html">下一页</a>
  </div>
</div>
		</div>
      </div>
    </div>
  </div>

<footer class="footer">
  <div class="p2 wrap">
	<div class="measure mt1 center">
	  <small>
		版权所有 © 2015 <a href="http://www.vouov.com">vouov</a><br/>
		Copyright © 2015 <a href="http://www.vouov.com">vouov</a> All rights reserved. <br/>
		<a href="/archive.html">archive</a>
	  </small>
<div class="social-icons">
  <div class="left">
    
      <a class="fa fa-github" href="https://github.com/vouov"></a>

	  <a class="fa fa-rss" href="feed.xml"></a>

      <a class="fa fa-twitter" href="http://weibo.com/445600369"></a>

      <a class="fa fa-envelope" href="mailto:yuminglong@gmail.com"></a>
  </div>
  <div class="right">
  </div>
</div>
<div class="clearfix"></div>
	</div>
  </div>
</footer>

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254468510'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1254468510' type='text/javascript'%3E%3C/script%3E"));</script>
</body>
</html>


	

