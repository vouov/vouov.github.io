<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>清晨迷雾</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="keywords" content="">
	<meta name="generator" content="清晨迷雾">

	<!-- Fav and touch icons -->
	<link rel="shortcut icon" href="favicon.ico">

	<!-- Custom CSS -->
	<link rel="stylesheet" href="css/pixyll.css" type="text/css">

	<!-- Fonts -->
	<link href='//fonts.useso.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
	<link href='//fonts.useso.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
	<link rel="stylesheet" href="css/highlight/default.css">
	<script src="js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head><body class="">
  <div class="site-wrap">
<header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="" class="site-title">清晨迷雾de小站</a>

      <nav class="site-nav right">
<a href="index.html">首页</a>
<a href="about.html">关于</a>
<a href="feed.xml">订阅</a>
      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
		<div class="home">
		  <div class="posts">
					<div class="post">
						<a href="blog/2015-03-15-dubbo.html" class="post-link">
						  <h3 class="h2 post-title">Dubbo使用总结</h3>
						  <p class="post-meta">2015年03月15日</p>
						</a>
						<p class="post-summary"><p><a href="http://alibaba.github.io/dubbo-doc-static/Home-zh.htm">Dubbo</a> 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p><p>其核心部分包含:</p>
<ul>
  <li><strong>远程通讯</strong> : 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>
  <li><strong>集群容错</strong> : 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
  <li><strong>自动发现</strong>: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>
</ul><p><strong>Dubbo能做什么？</strong></p>
<ul>
  <li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li>
  <li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li>
  <li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li>
</ul><p>上面是官方对于Dubbo一些描述, 对于稳定性是经过阿里巴巴验证过的,所以稳定是能够得到保证的.<br/>对于不同公司和不同的团队,有着各种需求和情况,那么我们就要探索如何使用Dubbo,使Dubbo能够很好的和我们的目标一致.</p><p><strong>应该怎么使用dubbo?</strong></p>
<ul>
  <li><strong>从零开始</strong><br/> 从头开始使用dubbo是比较简单的,我们可以完全按照dubbo官方指导实现. 具体项目示例请参照<a href="https://github.com/alibaba/dubbo/tree/master/dubbo-demo">https://github.com/alibaba/dubbo/tree/master/dubbo-demo</a></li>
  <li><strong>已有项目改造</strong><br/> 如果我们是spring的项目,那么我们可以平滑的过度到dubbo, 具体的实现思路是我们在编译阶段提取我们spring的service,生成consumer和provider文件配置,然后通过启动dubbo来加载我们的服务</li>
</ul><p>接下来我们重点讲述如何对于现有spring项目改造成dubbo<br/> 首先如果我们使用dubbo远程服务调用,那么我们如何保证事务? 如果要保证事务,我们需要把所要运新的服务在一台机器执行, 即官方所谓Best Efforts 1PC模式.那我们就要保证暴露的服务尽量是一个事务.<br/> 改造的思路是通过约定开发,达到开发和部署分离.开发采用传统的开发方式,在服务器发布时自动提取service,具体实现通过使用java的APT来实现.具体实现已经实现,后面有时间把具体的实现放到github上.</p><p><strong>dubbo如何启动?</strong><br/> java com.alibaba.dubbo.container.Main</p><p><strong>dubbo如何停止?</strong><br/> 优雅停机,Dubbo是通过JDK的ShutdownHook来完成优雅停机的，所以如果用户使用"kill -9 PID"等强制关闭指令，是不会执行优雅停机的，只有通过"kill PID"时，才会执行。</p></p>
					 </div>
					<div class="post">
						<a href="blog/2015-03-12-java-excel-template-export-big-data.html" class="post-link">
						  <h3 class="h2 post-title">POI根据Excel模板导出大数据</h3>
						  <p class="post-meta">2015年03月12日</p>
						</a>
						<p class="post-summary"><p>在一些项目中,需要导出数据, 如果编程实现POI样式等比较麻烦,所以一般根据模板来导出数据,之前使用过JXLS来实现,对于小数据比较好用,但是对于数据量比较大就比较慢,甚至死掉,不能导出.</p><p>经过一段时间研究POI,发现POI的SXSSF支持大数据导出,经过测试有很好的性能.实现有两种思路:</p>
<ul>
  <li>通过Excel文件copy样式等, 经过长时间验证和测试,有缺陷,会丢掉一些样式,不能完美达到目标</li>
  <li>通过修改模板文件,然后直接输出,经过测试验证,这种能够很好的解决大数据导出问题.</li>
</ul><p>下面我们给出第二种思路的具体实现,经过测试导出5W条数据大概需要4S,这个测试结果非常快. 如果使用标准POI XSSF来实现,会卡死不会输出.</p>
<pre><code class="java">/**
     * 根据Excel模板导出数据,支持大数据导出
     *
     * @param templateInputStream
     * @param data
     * @param outputStream
     * @param &lt;T&gt;
     * @throws IOException
     * @throws InvalidFormatException
     */
public static &lt;T&gt; void generateExcel(InputStream templateInputStream, 
Iterator&lt;T&gt; data, OutputStream outputStream) throws IOException, InvalidFormatException {
	// 通过类加载器获取模板
	XSSFWorkbook workbook = new XSSFWorkbook(templateInputStream);
	XSSFSheet sheet = workbook.getSheetAt(0);
	XSSFRow row = sheet.getRow(1);

	List&lt;CellStyle&gt; cellStyles = new ArrayList&lt;CellStyle&gt;();
	List&lt;String&gt; cellValues = new ArrayList&lt;String&gt;();
	Map&lt;Integer, String&gt; cellFormatMap = new HashMap&lt;Integer, String&gt;();
	Pattern pattern = Pattern.compile(&quot;^\\$\\{([\\w\\.]+)\\}$&quot;);
	for (int i = 0; i &lt; row.getLastCellNum(); i++) {
		XSSFCell cell = row.getCell(i);
		cellStyles.add(cell.getCellStyle());
		String cellValue = cell.getStringCellValue();
		cellValues.add(cellValue);
		if (cellValue != null) {
			Matcher matcher = pattern.matcher(cellValue);
			if (matcher.find()) {
				cellFormatMap.put(i, matcher.group(1));
			}
		}
	}

	sheet.removeRow(row);
	SXSSFWorkbook newWorkbook = new SXSSFWorkbook(workbook);
	Sheet newSheet = newWorkbook.getSheetAt(0);
	int rowNum = 1;
	while (data.hasNext()) {
		T t = data.next();
		JSONObject item = null;
		if (t instanceof JSONObject) {
			item = (JSONObject) t;
		} else {
			String json = JSON.toJSONString(t);
			item = JSON.parseObject(json);
		}

		Row newRow = newSheet.createRow(rowNum);
		for (int i = 0; i &lt; cellValues.size(); i++) {
			Cell newCell = newRow.createCell(i);
			newCell.setCellStyle(cellStyles.get(i));
			String newCellValue = cellValues.get(i);
			if (newCellValue != null &amp;&amp; cellFormatMap.containsKey(i)) {
				newCellValue = JsonUtils.getJSONValue(item, cellFormatMap.get(i));
			}
			newCell.setCellValue(newCellValue);
		}

		rowNum++;
	}
	newWorkbook.write(outputStream);
}
</code></pre></p>
					 </div>
					<div class="post">
						<a href="blog/2015-03-09-java-html-to-pdf.html" class="post-link">
						  <h3 class="h2 post-title">Java中HTML转PDF文档实现</h3>
						  <p class="post-meta">2015年03月09日</p>
						</a>
						<p class="post-summary"><p>之前我们讲述了如果通过html转换成word文档,现在我们讲述如何通过java实现转换HTML为PDF文档.<br/>首先我们把HTML文本通过jsoup整理成xhtml,然后通过flying-saucer-pdf-itext5或者itextpdf xmlworker转换成PDF.<br/>对于flying-saucer和itextpdf xmlworker都可以转换xhtml为PDF,但是在使用中我们发现flying-saucer对于样式的转换更加自然,而itextpdf的转换会丢失部分样式,所以接下来我们会给出两种实现方式,方便根据需要选择其中一种.</p><p>itextpdf xmlworker的maven依赖:</p>
<pre><code class="xml">&lt;dependency&gt;
	&lt;groupId&gt;com.itextpdf&lt;/groupId&gt;
	&lt;artifactId&gt;itextpdf&lt;/artifactId&gt;
	&lt;version&gt;5.5.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;com.itextpdf.tool&lt;/groupId&gt;
	&lt;artifactId&gt;xmlworker&lt;/artifactId&gt;
	&lt;version&gt;5.5.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>flying-saucer的maven依赖:</p>
<pre><code class="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt;
	&lt;artifactId&gt;flying-saucer-pdf-itext5&lt;/artifactId&gt;
	&lt;version&gt;9.0.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>html转成xhtml的jsoup参考实现如下:</p>
<pre><code class="java">/**
 * 清理HTML内容,转换成标准xhtml
 * @param html
 * @return
 */
public static String tidyHtml(String html){
	Document doc = Jsoup.parse(html);
	// Clean the document.
	//doc = new Cleaner(Whitelist.basicWithImages()).clean(doc);
	doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);
	doc.outputSettings().prettyPrint(true);

	doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
	// Get back the string of the body.
	return doc.html();
}
</code></pre><p>html转换成PDF的itextpdf xmlworker代码参考实现如下:</p>
<pre><code class="java">/**
 * 使用IText默认实现
 *
 * @param html
 * @param baseURL
 * @param os
 * @throws DocumentException
 * @throws IOException
 */
public static void html2Pdf(String html, String baseURL, OutputStream os) throws DocumentException, IOException {
	String xhtml = HtmlUtils.tidyHtml(html);
	xhtml = HtmlUtils.fillImageURL(xhtml, baseURL, null);
	// step 1
	Document document = new Document();
	// step 2
	PdfWriter writer = PdfWriter.getInstance(document, os);
	// step 3
	document.open();
	// step 4
	XMLWorkerHelper.getInstance().parseXHtml(writer, document, new ByteArrayInputStream(xhtml.getBytes(&quot;UTF-8&quot;)), Charset.forName(&quot;UTF-8&quot;));
	//step 5
	document.close();
}
</code></pre><p>html转换成PDF的flying-saucer代码参考实现如下:</p>
<pre><code class="java">/**
 * 使用flying-saucer-pdf-itext5实现
 *
 * @param html
 * @param baseURL
 * @param os
 * @throws IOException
 * @throws DocumentException
 */
public static void html2Pdf(String html, String baseURL, OutputStream os) throws IOException, DocumentException {
	ITextRenderer renderer = new ITextRenderer();
	String xhtml = HtmlUtils.tidyHtml(html);

	renderer.setDocumentFromString(xhtml, baseURL);

	// 解决中文支持问题
	ITextFontResolver fontResolver = renderer.getFontResolver();
	fontResolver.addFont(&quot;C:/Windows/Fonts/SIMSUN.TTC&quot;, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);
	//解决图片的相对路径问题
	renderer.getSharedContext().setBaseURL(baseURL);
	renderer.layout();
	renderer.createPDF(os);
}
</code></pre></p>
					 </div>
					<div class="post">
						<a href="blog/2015-03-08-java-html-to-word.html" class="post-link">
						  <h3 class="h2 post-title">Java中HTML转Word文档实现</h3>
						  <p class="post-meta">2015年03月08日</p>
						</a>
						<p class="post-summary"><p>有这样一个需求,我们要把数据库中的HTML格式文本字段导出为word,尝试了很多方法终于找到一种比较理想的方法.<br/>首先我们把HTML文本通过jsoup整理成xhtml,然后通过docx4j转换成word.<br/>HTML转换成xhtml还有一个jtidy,但是因为好久没有更新,并且有bug,所以推荐使用jsoup来整理.</p><p>docx4j的maven依赖:</p>
<pre><code class="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.docx4j&lt;/groupId&gt;
	&lt;artifactId&gt;docx4j-ImportXHTML&lt;/artifactId&gt;
	&lt;version&gt;3.2.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.jsoup&lt;/groupId&gt;
	&lt;artifactId&gt;jsoup&lt;/artifactId&gt;
	&lt;version&gt;1.8.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>html转成xhtml的jsoup参考实现如下:</p>
<pre><code class="java">/**
 * 清理HTML内容,转换成标准xhtml
 * @param html
 * @return
 */
public static String tidyHtml(String html){
	Document doc = Jsoup.parse(html);
	// Clean the document.
	//doc = new Cleaner(Whitelist.basicWithImages()).clean(doc);
	doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);
	doc.outputSettings().prettyPrint(true);

	doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
	// Get back the string of the body.
	return doc.html();
}
</code></pre><p>xhtml转换成word的java代码参考实现如下:</p>
<pre><code class="java">/**
 * html文本转换为word
 *
 * @param html
 * @param baseURL
 * @param os
 * @throws Docx4JException
 */
public static void html2Docx(String html, String baseURL, OutputStream os) throws Docx4JException {

	// To docx, with content controls
	WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.createPackage();

	XHTMLImporterImpl XHTMLImporter = new XHTMLImporterImpl(wordMLPackage);
	//XHTMLImporter.setDivHandler(new DivToSdt());
	wordMLPackage.getMainDocumentPart().getContent().addAll(
			XHTMLImporter.convert(html, baseURL));

	/*System.out.println(XmlUtils.marshaltoString(wordMLPackage
			.getMainDocumentPart().getJaxbElement(), true, true));*/

	wordMLPackage.save(os);
}
</code></pre></p>
					 </div>
					<div class="post">
						<a href="blog/2015-03-06-java-RSA.html" class="post-link">
						  <h3 class="h2 post-title">Java中RSA加密兼容Android实现</h3>
						  <p class="post-meta">2015年03月06日</p>
						</a>
						<p class="post-summary"><p>RSA加密主要有以下几个操作：</p>
<ul>
  <li><p><strong>RSA密钥生成</strong></p><p>密钥的生成有java程序生成,Linux命令生成,java keytool生成</p></li>
  <li><p><strong>RSA密钥存储</strong></p><p>密钥主要存储在java主机上,通过keytool导入或者生成</p></li>
  <li><p><strong>RSA根据公钥加密</strong></p><p>根据对方的公钥对明文加密生成密文,发送给对方</p></li>
  <li><p><strong>RSA根据密钥签名</strong></p><p>用自有的私钥对要明文签名,生成摘要签名,把明文和签名信息发送给你对方</p></li>
  <li><p><strong>RSA根据公钥验证签名</strong></p><p>对方接收到明文和签名,通过自有公钥发送给对方,对象通过发送过来的公钥进行验证.</p></li>
  <li><p><strong>RSA根据密钥解密</strong></p><p>对方接收到密文,通过对方的私钥解密接收到的密文</p></li>
</ul><p>数字签名（通常的数字签名）的基础是公钥密码体系（例如：RSA）。发送者有独一无二的公钥和私钥，公钥是公开的，私钥秘密保留。发送者利用私钥对数据的消息摘要进行数字签名，接收者利用发送者的公钥来验证数字签名，其实就是把加密过程颠倒过来使用。由于发送者的私钥是独一无二的，而且是秘密的，因此当能够验证解开数字签名的数字摘要是正确的后，那么我们就可以肯定发送者的身份了，这就是数字签名的基本原理。</p><p>在java中通常使用默认的方式和android的RSA是不能通用的,android默认使用的Provider是BouncyCastleProvider, 所以要把Java中的Provider也切换到BouncyCastleProvider.这样他们才能相互认识.<br/>BouncyCastle的Maven依赖:</p>
<pre><code>&lt;dependency&gt;
	&lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
	&lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
	&lt;version&gt;1.51&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>具体的实现请参照以下代码:</p>
<pre><code class="java">/**
 * RSA公钥/私钥/签名工具包
 * &lt;p/&gt;
 * 字符串格式的密钥在未在特殊说明情况下都为BASE64编码格式&lt;br/&gt;
 * 由于非对称加密速度极其缓慢，一般文件不使用它来加密而是使用对称加密，&lt;br/&gt;
 * 非对称加密算法可以用来对对称加密的密钥加密，这样保证密钥的安全也就保证了数据的安全
 *
 * @author yuml
 * @date 2015/3/4
 */
public class RSAUtils {


    static {
        //添加RSA第三方provider，主要解决android的兼容问题，提供统一的Provider
        Security.addProvider(new BouncyCastleProvider());
    }


    /**
     * 加密算法RSA
     */
    public static final String KEY_ALGORITHM_NAME = &quot;RSA&quot;;

    public static final String KEY_ALGORITHM_MODE = &quot;RSA/ECB/PKCS1Padding&quot;;


    /**
     * BouncyCastleProvider的名字
     */
    public static final String PROVIDER_NAME = &quot;BC&quot;;

    /**
     * 签名算法
     */
    public static final String SIGNATURE_ALGORITHM_NAME = &quot;MD5withRSA&quot;;

    /**
     * RSA最大加密明文大小
     */
    private static final int MAX_ENCRYPT_BLOCK = 117;

    /**
     * RSA最大解密密文大小
     */
    private static final int MAX_DECRYPT_BLOCK = 128;

    /**
     * &lt;p&gt;
     * 生成密钥对(公钥和私钥)
     * &lt;/p&gt;
     *
     * @return
     * @throws Exception
     */
    public static KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM_NAME, PROVIDER_NAME);
        keyPairGen.initialize(1024);
        KeyPair keyPair = keyPairGen.generateKeyPair();
        keyPair.getPublic();
        keyPair.getPrivate();
        return keyPair;
    }


    /**
     * 用私钥对信息生成数字签名
     *
     * @param data       已加密数据
     * @param privateKey 私钥
     * @return
     * @throws Exception
     */
    public static String sign(byte[] data, PrivateKey privateKey) throws Exception {
        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        signature.initSign(privateKey);
        signature.update(data);
        return Base64.encode(signature.sign());
    }

    /**
     * 校验数字签名
     *
     * @param data      已加密数据
     * @param publicKey 公钥
     * @param sign      数字签名
     * @return
     * @throws Exception
     */
    public static boolean verify(byte[] data, PublicKey publicKey, String sign)
            throws Exception {
        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        signature.initVerify(publicKey);
        signature.update(data);
        return signature.verify(Base64.decode(sign));
    }

    /**
     * 私钥解密
     *
     * @param encryptedData 已加密数据
     * @param privateKey    私钥
     * @return
     * @throws Exception
     */
    public static byte[] decryptByPrivateKey(byte[] encryptedData, PrivateKey privateKey)
            throws Exception {

        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_MODE, PROVIDER_NAME);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);

        int inputLen = encryptedData.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段解密
        while (inputLen - offSet &gt; 0) {
            if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) {
                cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_DECRYPT_BLOCK;
        }
        byte[] decryptedData = out.toByteArray();
        out.close();
        return decryptedData;
    }

    /**
     * 公钥解密
     *
     * @param encryptedData 已加密数据
     * @param publicKey     公钥
     * @return
     * @throws Exception
     */
    public static byte[] decryptByPublicKey(byte[] encryptedData, PublicKey publicKey)
            throws Exception {

        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_MODE, PROVIDER_NAME);
        cipher.init(Cipher.DECRYPT_MODE, publicKey);

        int inputLen = encryptedData.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段解密
        while (inputLen - offSet &gt; 0) {
            if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) {
                cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_DECRYPT_BLOCK;
        }
        byte[] decryptedData = out.toByteArray();
        out.close();
        return decryptedData;
    }

    /**
     * 公钥加密
     *
     * @param data      源数据
     * @param publicKey 公钥
     * @return
     * @throws Exception
     */
    public static byte[] encryptByPublicKey(byte[] data, PublicKey publicKey)
            throws Exception {
        // 对数据加密
        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_MODE, PROVIDER_NAME);
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);


        int inputLen = data.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段加密
        while (inputLen - offSet &gt; 0) {
            if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) {
                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(data, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_ENCRYPT_BLOCK;
        }
        byte[] encryptedData = out.toByteArray();
        out.close();
        return encryptedData;
    }

    /**
     * 私钥加密
     *
     * @param data       源数据
     * @param privateKey 私钥
     * @return
     * @throws Exception
     */
    public static byte[] encryptByPrivateKey(byte[] data, PrivateKey privateKey)
            throws Exception {

        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_MODE, PROVIDER_NAME);
        cipher.init(Cipher.ENCRYPT_MODE, privateKey);

        int inputLen = data.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段加密
        while (inputLen - offSet &gt; 0) {
            if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) {
                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(data, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_ENCRYPT_BLOCK;
        }
        byte[] encryptedData = out.toByteArray();
        out.close();
        return encryptedData;
    }


    /**
     * 从文件中输入流中加载公钥
     *
     * @param in 公钥输入流
     * @throws Exception 加载公钥时产生的异常
     */
    public PublicKey loadPublicKey(InputStream in) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(in));
        String readLine = null;
        StringBuilder sb = new StringBuilder();
        while ((readLine = br.readLine()) != null) {
            if (readLine.charAt(0) == &#39;-&#39;) {
                continue;
            } else {
                sb.append(readLine);
                sb.append(&#39;\r&#39;);
            }
        }
        return loadPublicKey(sb.toString());

    }

    /**
     * 从文件中加载私钥
     *
     * @param in 私钥文件名
     * @return 是否成功
     * @throws Exception
     */
    public PrivateKey loadPrivateKey(InputStream in) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(in));
        String readLine = null;
        StringBuilder sb = new StringBuilder();
        while ((readLine = br.readLine()) != null) {
            if (readLine.charAt(0) == &#39;-&#39;) {
                continue;
            } else {
                sb.append(readLine);
                sb.append(&#39;\r&#39;);
            }
        }
        return loadPrivateKey(sb.toString());
    }

    /**
     * 从字符串中加载私钥
     *
     * @param privateKey
     * @return
     * @throws Exception
     */
    public static PrivateKey loadPrivateKey(String privateKey) throws Exception {
        byte[] keyBytes = Base64.decode(privateKey);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM_NAME, PROVIDER_NAME);
        return keyFactory.generatePrivate(keySpec);
    }

    /**
     * 从字符串中加载公钥
     *
     * @param publicKey
     * @return
     * @throws Exception
     */
    public static PublicKey loadPublicKey(String publicKey) throws Exception {
        byte[] keyBytes = Base64.decode(publicKey);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM_NAME, PROVIDER_NAME);
        return keyFactory.generatePublic(keySpec);
    }

    /**
     * 从keystore中读取私钥
     *
     * @param alias
     * @param path     包含私钥的证书路径
     * @param password
     * @return 私钥PrivateKey
     * @throws Exception
     */
    public static PrivateKey loadKeyStorePrivateKey(String alias, String path, String password) throws Exception {
        FileInputStream fis = new FileInputStream(path);
        char[] passwordChars = null;
        if ((password != null) || &quot;&quot;.equals(password.trim())) {
            passwordChars = password.toCharArray();
        }

        KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;);
        keyStore.load(fis, passwordChars);
        fis.close();
        String keyAlias = alias;
        if (alias == null) {
            Enumeration&lt;String&gt; en = keyStore.aliases();
            if (en.hasMoreElements()) {
                keyAlias = en.nextElement();
            }
        }
        return (PrivateKey) keyStore.getKey(keyAlias, passwordChars);
    }

    /**
     * 从keystore中读取私钥
     *
     * @param path     包含私钥的证书路径
     * @param password
     * @return 私钥PrivateKey
     * @throws Exception
     */
    public static PrivateKey loadKeyStorePrivateKey(String path, String password) throws Exception {
        return loadKeyStorePrivateKey(null, path, password);
    }

    /**
     * 从keystore中读取公钥
     *
     * @param alias
     * @param path     包含公钥的证书路径
     * @param password
     * @return
     * @throws Exception
     */
    public static PublicKey loadKeyStorePublicKey(String alias, String path, String password) throws Exception {
        FileInputStream fis = new FileInputStream(path);
        char[] passwordChars = null;
        if ((password != null) || &quot;&quot;.equals(password.trim())) {
            passwordChars = password.toCharArray();
        }

        KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;);
        keyStore.load(fis, passwordChars);
        fis.close();
        String keyAlias = alias;
        if (alias == null) {
            Enumeration&lt;String&gt; en = keyStore.aliases();
            if (en.hasMoreElements()) {
                keyAlias = en.nextElement();
            }
        }
        return keyStore.getCertificate(keyAlias).getPublicKey();
    }

    /**
     * 从keystore中读取公钥
     *
     * @param path     包含公钥的证书路径
     * @param password
     * @return
     * @throws Exception
     */
    public static PublicKey loadKeyStorePublicKey(String path, String password) throws Exception {
        return loadKeyStorePublicKey(null, path, password);
    }

    /**
     * 根据公钥n、e生成公钥
     *
     * @param modulus        公钥n串
     * @param publicExponent 公钥e串
     * @return 返回公钥PublicKey
     * @throws Exception
     */
    public static PublicKey loadPublicKey(String modulus, String publicExponent) throws Exception {
        KeySpec publicKeySpec = new RSAPublicKeySpec(
                new BigInteger(modulus, 16), new BigInteger(publicExponent, 16));
        KeyFactory factory = KeyFactory.getInstance(KEY_ALGORITHM_NAME, PROVIDER_NAME);
        PublicKey publicKey = factory.generatePublic(publicKeySpec);
        return publicKey;
    }

}

</code></pre></p>
					 </div>
		  </div>
<div class="pagination clearfix mb1 mt4">
  <div class="left">
			<span class="pagination-item disabled">上一页</span>
  </div>
  <div class="right">
      <a class="pagination-item" href="2_index.html">下一页</a>
  </div>
</div>
		</div>
      </div>
    </div>
  </div>

<footer class="footer">
  <div class="p2 wrap">
	<div class="measure mt1 center">
	  <small>
		版权所有 © 2015 <a href="http://www.vouov.com">vouov</a><br/>
		Copyright © 2015 <a href="http://www.vouov.com">vouov</a> All rights reserved. <br/>
		<a href="/archive.html">archive</a>
	  </small>
<div class="social-icons">
  <div class="left">
    
      <a class="fa fa-github" href="https://github.com/vouov"></a>

	  <a class="fa fa-rss" href="feed.xml"></a>

      <a class="fa fa-twitter" href="http://weibo.com/445600369"></a>

      <a class="fa fa-envelope" href="mailto:yuminglong@gmail.com"></a>
  </div>
  <div class="right">
	  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254468510'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1254468510%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
  </div>
</div>
<div class="clearfix"></div>
	</div>
  </div>
</footer>
</body>
</html>


	

