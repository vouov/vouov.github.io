<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>http://www.vouov.com</link>
    <atom:link href="http://www.vouov.com/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>星期三, 18 三月 2015 17:21:08 +0800</pubDate>
    <lastBuildDate>星期三, 18 三月 2015 17:21:08 +0800</lastBuildDate>

    <item>
      <title>Maven中使用APT</title>
      <link>http://www.vouov.com/blog/2015-03-17-maven-apt.html</link>
      <pubDate>星期二, 17 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-17-maven-apt.html</guid>
      	<description>
	&lt;p&gt;APT(Annotation Processing Tool)是一个java注解处理工具,主要运行在JDK编译阶段,我们可以简单理解为预编译的处理工具类, 就是我们在执行我们传统的编译前,做一些预处理,可以是资源文件的,也可以是JAVA类的,把一部分注解在编译时解释为传统的类,以提高运行时效率,在运行时,这些注解就不要再执行,即使我们使用字节码优化也不能达到这种类似于原生代码的效率.&lt;/p&gt;&lt;p&gt;如果使用APT,建议使用JDK的最小版本为1.6. APT从在JDK 1.5开始支持,但是从1.6版本开始才稳定和可用性有所提高,简化开发部署的难度.&lt;br/&gt;以下所有的阐述都是针对1.6版本以后.&lt;/p&gt;&lt;p&gt;JDK 1.6版本后添加了几个javac参数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;  -proc:{none,only}          Control whether annotation processing and/or compilation is done.
  -processor &amp;lt;class1&amp;gt;[,&amp;lt;class2&amp;gt;,&amp;lt;class3&amp;gt;...]
							 Names of the annotation processors to run; 
							 bypasses default discovery process
  -processorpath &amp;lt;path&amp;gt;      Specify where to find annotation processors
  -s &amp;lt;directory&amp;gt;             Specify where to place generated source files
  -implicit:{none,class}     Specify whether or not to generate class files 
							 for implicitly referenced files
  -Akey[=value]              Options to pass to annotation processors
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么我们在maven工程中只要添加javac参数就可以了.如下示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;
	&amp;lt;configuration&amp;gt;
		&amp;lt;proc&amp;gt;only&amp;lt;/proc&amp;gt;
		&amp;lt;annotationProcessors&amp;gt;
			&amp;lt;annotationProcessor&amp;gt;com.annotation.processor.AnnotationProcessor&amp;lt;/annotationProcessor&amp;gt;
		&amp;lt;/annotationProcessors&amp;gt;
		&amp;lt;source&amp;gt;1.6&amp;lt;/source&amp;gt;
		&amp;lt;target&amp;gt;1.6&amp;lt;/target&amp;gt;
	&amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了以上方法,也有一些插件来处理,如&lt;a href=&quot;https://github.com/querydsl/apt-maven-plugin&quot;&gt;apt-maven-plugin&lt;/a&gt;,不过主要是针对eclipse的m2e插件的,具体代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;com.mysema.maven&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;apt-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.3&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;process&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;outputDirectory&amp;gt;target/generated-sources/java&amp;lt;/outputDirectory&amp;gt;
                &amp;lt;processor&amp;gt;com.mysema.query.apt.jpa.JPAAnnotationProcessor&amp;lt;/processor&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
	</description>
    </item>
    <item>
      <title>Dubbo使用总结</title>
      <link>http://www.vouov.com/blog/2015-03-15-dubbo.html</link>
      <pubDate>星期日, 15 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-15-dubbo.html</guid>
      	<description>
	&lt;p&gt;&lt;a href=&quot;http://alibaba.github.io/dubbo-doc-static/Home-zh.htm&quot;&gt;Dubbo&lt;/a&gt; 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。&lt;/p&gt;&lt;p&gt;其核心部分包含:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;远程通讯&lt;/strong&gt; : 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;集群容错&lt;/strong&gt; : 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自动发现&lt;/strong&gt;: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Dubbo能做什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。&lt;/li&gt;
  &lt;li&gt;软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。&lt;/li&gt;
  &lt;li&gt;服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面是官方对于Dubbo一些描述, 对于稳定性是经过阿里巴巴验证过的,所以稳定是能够得到保证的.&lt;br/&gt;对于不同公司和不同的团队,有着各种需求和情况,那么我们就要探索如何使用Dubbo,使Dubbo能够很好的和我们的目标一致.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应该怎么使用dubbo?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;从零开始&lt;/strong&gt;&lt;br/&gt; 从头开始使用dubbo是比较简单的,我们可以完全按照dubbo官方指导实现. 具体项目示例请参照&lt;a href=&quot;https://github.com/alibaba/dubbo/tree/master/dubbo-demo&quot;&gt;https://github.com/alibaba/dubbo/tree/master/dubbo-demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;已有项目改造&lt;/strong&gt;&lt;br/&gt; 如果我们是spring的项目,那么我们可以平滑的过度到dubbo, 具体的实现思路是我们在编译阶段提取我们spring的service,生成consumer和provider文件配置,然后通过启动dubbo来加载我们的服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们重点讲述如何对于现有spring项目改造成dubbo&lt;br/&gt; 首先如果我们使用dubbo远程服务调用,那么我们如何保证事务? 如果要保证事务,我们需要把所要运新的服务在一台机器执行, 即官方所谓Best Efforts 1PC模式.那我们就要保证暴露的服务尽量是一个事务.&lt;br/&gt; 改造的思路是通过约定开发,达到开发和部署分离.开发采用传统的开发方式,在服务器发布时自动提取service,具体实现通过使用java的APT来实现.具体实现已经实现,后面有时间把具体的实现放到github上.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;dubbo如何启动?&lt;/strong&gt;&lt;br/&gt; java com.alibaba.dubbo.container.Main&lt;/p&gt;&lt;p&gt;&lt;strong&gt;dubbo如何停止?&lt;/strong&gt;&lt;br/&gt; 优雅停机,Dubbo是通过JDK的ShutdownHook来完成优雅停机的，所以如果用户使用&quot;kill -9 PID&quot;等强制关闭指令，是不会执行优雅停机的，只有通过&quot;kill PID&quot;时，才会执行。&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>POI根据Excel模板导出大数据</title>
      <link>http://www.vouov.com/blog/2015-03-12-java-excel-template-export-big-data.html</link>
      <pubDate>星期四, 12 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-12-java-excel-template-export-big-data.html</guid>
      	<description>
	&lt;p&gt;在一些项目中,需要导出数据, 如果编程实现POI样式等比较麻烦,所以一般根据模板来导出数据,之前使用过JXLS来实现,对于小数据比较好用,但是对于数据量比较大就比较慢,甚至死掉,不能导出.&lt;/p&gt;&lt;p&gt;经过一段时间研究POI,发现POI的SXSSF支持大数据导出,经过测试有很好的性能.实现有两种思路:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过Excel文件copy样式等, 经过长时间验证和测试,有缺陷,会丢掉一些样式,不能完美达到目标&lt;/li&gt;
  &lt;li&gt;通过修改模板文件,然后直接输出,经过测试验证,这种能够很好的解决大数据导出问题.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们给出第二种思路的具体实现,经过测试导出5W条数据大概需要4S,这个测试结果非常快. 如果使用标准POI XSSF来实现,会卡死不会输出.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
     * 根据Excel模板导出数据,支持大数据导出
     *
     * @param templateInputStream
     * @param data
     * @param outputStream
     * @param &amp;lt;T&amp;gt;
     * @throws IOException
     * @throws InvalidFormatException
     */
public static &amp;lt;T&amp;gt; void generateExcel(InputStream templateInputStream, 
Iterator&amp;lt;T&amp;gt; data, OutputStream outputStream) throws IOException, InvalidFormatException {
	// 通过类加载器获取模板
	XSSFWorkbook workbook = new XSSFWorkbook(templateInputStream);
	XSSFSheet sheet = workbook.getSheetAt(0);
	XSSFRow row = sheet.getRow(1);

	List&amp;lt;CellStyle&amp;gt; cellStyles = new ArrayList&amp;lt;CellStyle&amp;gt;();
	List&amp;lt;String&amp;gt; cellValues = new ArrayList&amp;lt;String&amp;gt;();
	Map&amp;lt;Integer, String&amp;gt; cellFormatMap = new HashMap&amp;lt;Integer, String&amp;gt;();
	Pattern pattern = Pattern.compile(&amp;quot;^\\$\\{([\\w\\.]+)\\}$&amp;quot;);
	for (int i = 0; i &amp;lt; row.getLastCellNum(); i++) {
		XSSFCell cell = row.getCell(i);
		cellStyles.add(cell.getCellStyle());
		String cellValue = cell.getStringCellValue();
		cellValues.add(cellValue);
		if (cellValue != null) {
			Matcher matcher = pattern.matcher(cellValue);
			if (matcher.find()) {
				cellFormatMap.put(i, matcher.group(1));
			}
		}
	}

	sheet.removeRow(row);
	SXSSFWorkbook newWorkbook = new SXSSFWorkbook(workbook);
	Sheet newSheet = newWorkbook.getSheetAt(0);
	int rowNum = 1;
	while (data.hasNext()) {
		T t = data.next();
		JSONObject item = null;
		if (t instanceof JSONObject) {
			item = (JSONObject) t;
		} else {
			String json = JSON.toJSONString(t);
			item = JSON.parseObject(json);
		}

		Row newRow = newSheet.createRow(rowNum);
		for (int i = 0; i &amp;lt; cellValues.size(); i++) {
			Cell newCell = newRow.createCell(i);
			newCell.setCellStyle(cellStyles.get(i));
			String newCellValue = cellValues.get(i);
			if (newCellValue != null &amp;amp;&amp;amp; cellFormatMap.containsKey(i)) {
				newCellValue = JsonUtils.getJSONValue(item, cellFormatMap.get(i));
			}
			newCell.setCellValue(newCellValue);
		}

		rowNum++;
	}
	newWorkbook.write(outputStream);
}
&lt;/code&gt;&lt;/pre&gt;
	</description>
    </item>
    <item>
      <title>Java中HTML转PDF文档实现</title>
      <link>http://www.vouov.com/blog/2015-03-09-java-html-to-pdf.html</link>
      <pubDate>星期一, 9 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-09-java-html-to-pdf.html</guid>
      	<description>
	&lt;p&gt;之前我们讲述了如果通过html转换成word文档,现在我们讲述如何通过java实现转换HTML为PDF文档.&lt;br/&gt;首先我们把HTML文本通过jsoup整理成xhtml,然后通过flying-saucer-pdf-itext5或者itextpdf xmlworker转换成PDF.&lt;br/&gt;对于flying-saucer和itextpdf xmlworker都可以转换xhtml为PDF,但是在使用中我们发现flying-saucer对于样式的转换更加自然,而itextpdf的转换会丢失部分样式,所以接下来我们会给出两种实现方式,方便根据需要选择其中一种.&lt;/p&gt;&lt;p&gt;itextpdf xmlworker的maven依赖:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;com.itextpdf&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;itextpdf&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;5.5.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;com.itextpdf.tool&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;xmlworker&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;5.5.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;flying-saucer的maven依赖:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.xhtmlrenderer&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;flying-saucer-pdf-itext5&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;9.0.7&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;html转成xhtml的jsoup参考实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 清理HTML内容,转换成标准xhtml
 * @param html
 * @return
 */
public static String tidyHtml(String html){
	Document doc = Jsoup.parse(html);
	// Clean the document.
	//doc = new Cleaner(Whitelist.basicWithImages()).clean(doc);
	doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);
	doc.outputSettings().prettyPrint(true);

	doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
	// Get back the string of the body.
	return doc.html();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;html转换成PDF的itextpdf xmlworker代码参考实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 使用IText默认实现
 *
 * @param html
 * @param baseURL
 * @param os
 * @throws DocumentException
 * @throws IOException
 */
public static void html2Pdf(String html, String baseURL, OutputStream os) throws DocumentException, IOException {
	String xhtml = HtmlUtils.tidyHtml(html);
	xhtml = HtmlUtils.fillImageURL(xhtml, baseURL, null);
	// step 1
	Document document = new Document();
	// step 2
	PdfWriter writer = PdfWriter.getInstance(document, os);
	// step 3
	document.open();
	// step 4
	XMLWorkerHelper.getInstance().parseXHtml(writer, document, new ByteArrayInputStream(xhtml.getBytes(&amp;quot;UTF-8&amp;quot;)), Charset.forName(&amp;quot;UTF-8&amp;quot;));
	//step 5
	document.close();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;html转换成PDF的flying-saucer代码参考实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 使用flying-saucer-pdf-itext5实现
 *
 * @param html
 * @param baseURL
 * @param os
 * @throws IOException
 * @throws DocumentException
 */
public static void html2Pdf(String html, String baseURL, OutputStream os) throws IOException, DocumentException {
	ITextRenderer renderer = new ITextRenderer();
	String xhtml = HtmlUtils.tidyHtml(html);

	renderer.setDocumentFromString(xhtml, baseURL);

	// 解决中文支持问题
	ITextFontResolver fontResolver = renderer.getFontResolver();
	fontResolver.addFont(&amp;quot;C:/Windows/Fonts/SIMSUN.TTC&amp;quot;, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED);
	//解决图片的相对路径问题
	renderer.getSharedContext().setBaseURL(baseURL);
	renderer.layout();
	renderer.createPDF(os);
}
&lt;/code&gt;&lt;/pre&gt;
	</description>
    </item>
    <item>
      <title>Java中HTML转Word文档实现</title>
      <link>http://www.vouov.com/blog/2015-03-08-java-html-to-word.html</link>
      <pubDate>星期日, 8 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-08-java-html-to-word.html</guid>
      	<description>
	&lt;p&gt;有这样一个需求,我们要把数据库中的HTML格式文本字段导出为word,尝试了很多方法终于找到一种比较理想的方法.&lt;br/&gt;首先我们把HTML文本通过jsoup整理成xhtml,然后通过docx4j转换成word.&lt;br/&gt;HTML转换成xhtml还有一个jtidy,但是因为好久没有更新,并且有bug,所以推荐使用jsoup来整理.&lt;/p&gt;&lt;p&gt;docx4j的maven依赖:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.docx4j&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;docx4j-ImportXHTML&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;3.2.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.jsoup&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;jsoup&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.8.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;html转成xhtml的jsoup参考实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 清理HTML内容,转换成标准xhtml
 * @param html
 * @return
 */
public static String tidyHtml(String html){
	Document doc = Jsoup.parse(html);
	// Clean the document.
	//doc = new Cleaner(Whitelist.basicWithImages()).clean(doc);
	doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);
	doc.outputSettings().prettyPrint(true);

	doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);
	// Get back the string of the body.
	return doc.html();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;xhtml转换成word的java代码参考实现如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * html文本转换为word
 *
 * @param html
 * @param baseURL
 * @param os
 * @throws Docx4JException
 */
public static void html2Docx(String html, String baseURL, OutputStream os) throws Docx4JException {

	// To docx, with content controls
	WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.createPackage();

	XHTMLImporterImpl XHTMLImporter = new XHTMLImporterImpl(wordMLPackage);
	//XHTMLImporter.setDivHandler(new DivToSdt());
	wordMLPackage.getMainDocumentPart().getContent().addAll(
			XHTMLImporter.convert(html, baseURL));

	/*System.out.println(XmlUtils.marshaltoString(wordMLPackage
			.getMainDocumentPart().getJaxbElement(), true, true));*/

	wordMLPackage.save(os);
}
&lt;/code&gt;&lt;/pre&gt;
	</description>
    </item>
    <item>
      <title>Java中RSA加密兼容Android实现</title>
      <link>http://www.vouov.com/blog/2015-03-06-java-RSA.html</link>
      <pubDate>星期五, 6 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-06-java-RSA.html</guid>
      	<description>
	&lt;p&gt;RSA加密主要有以下几个操作：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;RSA密钥生成&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;密钥的生成有java程序生成,Linux命令生成,java keytool生成&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;RSA密钥存储&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;密钥主要存储在java主机上,通过keytool导入或者生成&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;RSA根据公钥加密&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;根据对方的公钥对明文加密生成密文,发送给对方&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;RSA根据密钥签名&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;用自有的私钥对要明文签名,生成摘要签名,把明文和签名信息发送给你对方&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;RSA根据公钥验证签名&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对方接收到明文和签名,通过自有公钥发送给对方,对象通过发送过来的公钥进行验证.&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;RSA根据密钥解密&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对方接收到密文,通过对方的私钥解密接收到的密文&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数字签名（通常的数字签名）的基础是公钥密码体系（例如：RSA）。发送者有独一无二的公钥和私钥，公钥是公开的，私钥秘密保留。发送者利用私钥对数据的消息摘要进行数字签名，接收者利用发送者的公钥来验证数字签名，其实就是把加密过程颠倒过来使用。由于发送者的私钥是独一无二的，而且是秘密的，因此当能够验证解开数字签名的数字摘要是正确的后，那么我们就可以肯定发送者的身份了，这就是数字签名的基本原理。&lt;/p&gt;&lt;p&gt;在java中通常使用默认的方式和android的RSA是不能通用的,android默认使用的Provider是BouncyCastleProvider, 所以要把Java中的Provider也切换到BouncyCastleProvider.这样他们才能相互认识.&lt;br/&gt;BouncyCastle的Maven依赖:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.bouncycastle&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;bcprov-jdk15on&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.51&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的实现请参照以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * RSA公钥/私钥/签名工具包
 * &amp;lt;p/&amp;gt;
 * 字符串格式的密钥在未在特殊说明情况下都为BASE64编码格式&amp;lt;br/&amp;gt;
 * 由于非对称加密速度极其缓慢，一般文件不使用它来加密而是使用对称加密，&amp;lt;br/&amp;gt;
 * 非对称加密算法可以用来对对称加密的密钥加密，这样保证密钥的安全也就保证了数据的安全
 *
 * @author yuml
 * @date 2015/3/4
 */
public class RSAUtils {


    static {
        //添加RSA第三方provider，主要解决android的兼容问题，提供统一的Provider
        Security.addProvider(new BouncyCastleProvider());
    }


    /**
     * 加密算法RSA
     */
    public static final String KEY_ALGORITHM_NAME = &amp;quot;RSA&amp;quot;;

    public static final String KEY_ALGORITHM_MODE = &amp;quot;RSA/ECB/PKCS1Padding&amp;quot;;


    /**
     * BouncyCastleProvider的名字
     */
    public static final String PROVIDER_NAME = &amp;quot;BC&amp;quot;;

    /**
     * 签名算法
     */
    public static final String SIGNATURE_ALGORITHM_NAME = &amp;quot;MD5withRSA&amp;quot;;

    /**
     * RSA最大加密明文大小
     */
    private static final int MAX_ENCRYPT_BLOCK = 117;

    /**
     * RSA最大解密密文大小
     */
    private static final int MAX_DECRYPT_BLOCK = 128;

    /**
     * &amp;lt;p&amp;gt;
     * 生成密钥对(公钥和私钥)
     * &amp;lt;/p&amp;gt;
     *
     * @return
     * @throws Exception
     */
    public static KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM_NAME, PROVIDER_NAME);
        keyPairGen.initialize(1024);
        KeyPair keyPair = keyPairGen.generateKeyPair();
        keyPair.getPublic();
        keyPair.getPrivate();
        return keyPair;
    }


    /**
     * 用私钥对信息生成数字签名
     *
     * @param data       已加密数据
     * @param privateKey 私钥
     * @return
     * @throws Exception
     */
    public static String sign(byte[] data, PrivateKey privateKey) throws Exception {
        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        signature.initSign(privateKey);
        signature.update(data);
        return Base64.encode(signature.sign());
    }

    /**
     * 校验数字签名
     *
     * @param data      已加密数据
     * @param publicKey 公钥
     * @param sign      数字签名
     * @return
     * @throws Exception
     */
    public static boolean verify(byte[] data, PublicKey publicKey, String sign)
            throws Exception {
        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        signature.initVerify(publicKey);
        signature.update(data);
        return signature.verify(Base64.decode(sign));
    }

    /**
     * 私钥解密
     *
     * @param encryptedData 已加密数据
     * @param privateKey    私钥
     * @return
     * @throws Exception
     */
    public static byte[] decryptByPrivateKey(byte[] encryptedData, PrivateKey privateKey)
            throws Exception {

        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_MODE, PROVIDER_NAME);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);

        int inputLen = encryptedData.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段解密
        while (inputLen - offSet &amp;gt; 0) {
            if (inputLen - offSet &amp;gt; MAX_DECRYPT_BLOCK) {
                cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_DECRYPT_BLOCK;
        }
        byte[] decryptedData = out.toByteArray();
        out.close();
        return decryptedData;
    }

    /**
     * 公钥解密
     *
     * @param encryptedData 已加密数据
     * @param publicKey     公钥
     * @return
     * @throws Exception
     */
    public static byte[] decryptByPublicKey(byte[] encryptedData, PublicKey publicKey)
            throws Exception {

        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_MODE, PROVIDER_NAME);
        cipher.init(Cipher.DECRYPT_MODE, publicKey);

        int inputLen = encryptedData.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段解密
        while (inputLen - offSet &amp;gt; 0) {
            if (inputLen - offSet &amp;gt; MAX_DECRYPT_BLOCK) {
                cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_DECRYPT_BLOCK;
        }
        byte[] decryptedData = out.toByteArray();
        out.close();
        return decryptedData;
    }

    /**
     * 公钥加密
     *
     * @param data      源数据
     * @param publicKey 公钥
     * @return
     * @throws Exception
     */
    public static byte[] encryptByPublicKey(byte[] data, PublicKey publicKey)
            throws Exception {
        // 对数据加密
        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_MODE, PROVIDER_NAME);
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);


        int inputLen = data.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段加密
        while (inputLen - offSet &amp;gt; 0) {
            if (inputLen - offSet &amp;gt; MAX_ENCRYPT_BLOCK) {
                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(data, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_ENCRYPT_BLOCK;
        }
        byte[] encryptedData = out.toByteArray();
        out.close();
        return encryptedData;
    }

    /**
     * 私钥加密
     *
     * @param data       源数据
     * @param privateKey 私钥
     * @return
     * @throws Exception
     */
    public static byte[] encryptByPrivateKey(byte[] data, PrivateKey privateKey)
            throws Exception {

        Cipher cipher = Cipher.getInstance(KEY_ALGORITHM_MODE, PROVIDER_NAME);
        cipher.init(Cipher.ENCRYPT_MODE, privateKey);

        int inputLen = data.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段加密
        while (inputLen - offSet &amp;gt; 0) {
            if (inputLen - offSet &amp;gt; MAX_ENCRYPT_BLOCK) {
                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(data, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_ENCRYPT_BLOCK;
        }
        byte[] encryptedData = out.toByteArray();
        out.close();
        return encryptedData;
    }


    /**
     * 从文件中输入流中加载公钥
     *
     * @param in 公钥输入流
     * @throws Exception 加载公钥时产生的异常
     */
    public PublicKey loadPublicKey(InputStream in) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(in));
        String readLine = null;
        StringBuilder sb = new StringBuilder();
        while ((readLine = br.readLine()) != null) {
            if (readLine.charAt(0) == &amp;#39;-&amp;#39;) {
                continue;
            } else {
                sb.append(readLine);
                sb.append(&amp;#39;\r&amp;#39;);
            }
        }
        return loadPublicKey(sb.toString());

    }

    /**
     * 从文件中加载私钥
     *
     * @param in 私钥文件名
     * @return 是否成功
     * @throws Exception
     */
    public PrivateKey loadPrivateKey(InputStream in) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(in));
        String readLine = null;
        StringBuilder sb = new StringBuilder();
        while ((readLine = br.readLine()) != null) {
            if (readLine.charAt(0) == &amp;#39;-&amp;#39;) {
                continue;
            } else {
                sb.append(readLine);
                sb.append(&amp;#39;\r&amp;#39;);
            }
        }
        return loadPrivateKey(sb.toString());
    }

    /**
     * 从字符串中加载私钥
     *
     * @param privateKey
     * @return
     * @throws Exception
     */
    public static PrivateKey loadPrivateKey(String privateKey) throws Exception {
        byte[] keyBytes = Base64.decode(privateKey);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM_NAME, PROVIDER_NAME);
        return keyFactory.generatePrivate(keySpec);
    }

    /**
     * 从字符串中加载公钥
     *
     * @param publicKey
     * @return
     * @throws Exception
     */
    public static PublicKey loadPublicKey(String publicKey) throws Exception {
        byte[] keyBytes = Base64.decode(publicKey);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM_NAME, PROVIDER_NAME);
        return keyFactory.generatePublic(keySpec);
    }

    /**
     * 从keystore中读取私钥
     *
     * @param alias
     * @param path     包含私钥的证书路径
     * @param password
     * @return 私钥PrivateKey
     * @throws Exception
     */
    public static PrivateKey loadKeyStorePrivateKey(String alias, String path, String password) throws Exception {
        FileInputStream fis = new FileInputStream(path);
        char[] passwordChars = null;
        if ((password != null) || &amp;quot;&amp;quot;.equals(password.trim())) {
            passwordChars = password.toCharArray();
        }

        KeyStore keyStore = KeyStore.getInstance(&amp;quot;PKCS12&amp;quot;);
        keyStore.load(fis, passwordChars);
        fis.close();
        String keyAlias = alias;
        if (alias == null) {
            Enumeration&amp;lt;String&amp;gt; en = keyStore.aliases();
            if (en.hasMoreElements()) {
                keyAlias = en.nextElement();
            }
        }
        return (PrivateKey) keyStore.getKey(keyAlias, passwordChars);
    }

    /**
     * 从keystore中读取私钥
     *
     * @param path     包含私钥的证书路径
     * @param password
     * @return 私钥PrivateKey
     * @throws Exception
     */
    public static PrivateKey loadKeyStorePrivateKey(String path, String password) throws Exception {
        return loadKeyStorePrivateKey(null, path, password);
    }

    /**
     * 从keystore中读取公钥
     *
     * @param alias
     * @param path     包含公钥的证书路径
     * @param password
     * @return
     * @throws Exception
     */
    public static PublicKey loadKeyStorePublicKey(String alias, String path, String password) throws Exception {
        FileInputStream fis = new FileInputStream(path);
        char[] passwordChars = null;
        if ((password != null) || &amp;quot;&amp;quot;.equals(password.trim())) {
            passwordChars = password.toCharArray();
        }

        KeyStore keyStore = KeyStore.getInstance(&amp;quot;PKCS12&amp;quot;);
        keyStore.load(fis, passwordChars);
        fis.close();
        String keyAlias = alias;
        if (alias == null) {
            Enumeration&amp;lt;String&amp;gt; en = keyStore.aliases();
            if (en.hasMoreElements()) {
                keyAlias = en.nextElement();
            }
        }
        return keyStore.getCertificate(keyAlias).getPublicKey();
    }

    /**
     * 从keystore中读取公钥
     *
     * @param path     包含公钥的证书路径
     * @param password
     * @return
     * @throws Exception
     */
    public static PublicKey loadKeyStorePublicKey(String path, String password) throws Exception {
        return loadKeyStorePublicKey(null, path, password);
    }

    /**
     * 根据公钥n、e生成公钥
     *
     * @param modulus        公钥n串
     * @param publicExponent 公钥e串
     * @return 返回公钥PublicKey
     * @throws Exception
     */
    public static PublicKey loadPublicKey(String modulus, String publicExponent) throws Exception {
        KeySpec publicKeySpec = new RSAPublicKeySpec(
                new BigInteger(modulus, 16), new BigInteger(publicExponent, 16));
        KeyFactory factory = KeyFactory.getInstance(KEY_ALGORITHM_NAME, PROVIDER_NAME);
        PublicKey publicKey = factory.generatePublic(publicKeySpec);
        return publicKey;
    }

}

&lt;/code&gt;&lt;/pre&gt;
	</description>
    </item>
    <item>
      <title>Java中AES加密兼容PHP等其他语言实现</title>
      <link>http://www.vouov.com/blog/2015-03-04-java-AES-compatible.html</link>
      <pubDate>星期三, 4 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-04-java-AES-compatible.html</guid>
      	<description>
	&lt;p&gt;在之前的项目中涉及到java和php通信时采用AES加密，但是因为一些算法差异，导致不能直接通信，java需要做补位操作才能实现，后换了一种算法协议。今天在整理加密算法时，发现可以通过补位的方式来达到和PHP的通信，具体实现参照了 &lt;a href=&quot;http://www.cnblogs.com/AloneSword/p/3485912.html&quot;&gt;AES加密CBC模式兼容互通四种编程语言平台&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;两种语言的差别主要是对于内容的填充实现上不一致.&lt;/p&gt;&lt;p&gt;AES支持五中模式：CBC，CFB，ECB，OFB，PCBC；支持三种填充：NoPadding，PKCS5Padding，ISO10126Padding。不支持SSL3Padding。不支持“NONE”模式。&lt;br/&gt;其中AES/ECB/NoPadding和我现在使用的AESUtil得出的结果相同(在16的整数倍情况下)。&lt;br/&gt;不带模式和填充来获取AES算法的时候，其默认使用ECB/PKCS5Padding。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;算法/模式/填充                16字节加密后数据长度        不满16字节加密后长度
AES/CBC/NoPadding             16                          不支持
AES/CBC/PKCS5Padding          32                          16
AES/CBC/ISO10126Padding       32                          16
AES/CFB/NoPadding             16                          原始数据长度
AES/CFB/PKCS5Padding          32                          16
AES/CFB/ISO10126Padding       32                          16
AES/ECB/NoPadding             16                          不支持
AES/ECB/PKCS5Padding          32                          16
AES/ECB/ISO10126Padding       32                          16
AES/OFB/NoPadding             16                          原始数据长度
AES/OFB/PKCS5Padding          32                          16
AES/OFB/ISO10126Padding       32                          16
AES/PCBC/NoPadding            16                          不支持
AES/PCBC/PKCS5Padding         32                          16
AES/PCBC/ISO10126Padding      32                          16
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，在原始数据长度为16的整数倍时，假如原始数据长度等于16*n，则使用NoPadding时加密后数据长度等于16*n，其它情况下加密数据长度等于16*(n+1)。在不足16的整数倍的情况下，假如原始数据长度等于16*n+m[其中m小于16]，除了NoPadding填充之外的任何方式，加密数据长度都等于16*(n+1)；NoPadding填充情况下，CBC、ECB和PCBC三种模式是不支持的，CFB、OFB两种模式下则加密数据长度等于原始数据长度。&lt;/p&gt;&lt;p&gt;我的主要实现思路是对于密码和IV我们通过MD5算法强制让所得到的byte[]长度是16的倍数，对于要加密的内容，先获取长度，如果长度不是16的倍数，则申请大于现有长度而且是16倍数的byte[]内存，然后通过拷贝把原有的内容拷贝到新申请的内存空间，这就相当于做了补零操作。其实就是实现了java的AES/CBC/ZeroPadding算法;对于解密也一样需要对末端的补零位清理，达到加密和解密的值相等；具体实现代码下面给出参考实现。&lt;/p&gt;&lt;p&gt;java参考代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 兼容PHP等其他语言AES加密、解密方法
 *
 * @param mode
 * @param data
 * @param password
 * @param iv
 * @return
 * @throws Exception
 */
public static byte[] aesZeroPadding(int mode, byte[] data, String password, String iv) throws Exception {
	SecretKeySpec secretKeySpec = new SecretKeySpec(
		StringUtils.getBytesUtf8(md5(password).substring(0, 16)), 
		&amp;quot;AES&amp;quot;);
	Cipher cipher = Cipher.getInstance(&amp;quot;AES/CBC/NoPadding&amp;quot;);

	IvParameterSpec ivParameterSpec = new IvParameterSpec(
		StringUtils.getBytesUtf8(md5(iv).substring(0, 16)));
	cipher.init(mode, secretKeySpec, ivParameterSpec);

	return cipher.doFinal(data);
}

/**
 * 兼容PHP等其他语言AES加密方法
 *
 * @param data
 * @param password
 * @param iv
 * @return
 * @throws Exception
 */
public static String encodeAESZeroPadding(String data, String password, String iv) {
	try {
		Cipher cipher = Cipher.getInstance(&amp;quot;AES/CBC/NoPadding&amp;quot;);
		//对内容不是16整数倍数时补位
		int blockSize = cipher.getBlockSize();
		byte[] bytes = StringUtils.getBytesUtf8(data);
		int dataBytesLength = bytes.length;
		int mod = dataBytesLength % blockSize;
		if (mod != 0) {
			dataBytesLength = dataBytesLength + (blockSize - mod);
		}
		byte[] newBytes = new byte[dataBytesLength];
		System.arraycopy(bytes, 0, newBytes, 0, bytes.length);
		return Base64.encode(aesZeroPadding(Cipher.ENCRYPT_MODE, newBytes, password, iv));
	} catch (Exception e) {
		logger.error(&amp;quot;AES ZeroPadding模式加密失败&amp;quot;, e);
		throw new RuntimeException(e);
	}
}

/**
 * 兼容PHP等其他语言AES解密方法
 *
 * @param data
 * @param password
 * @param iv
 * @return
 * @throws Exception
 */
public static String decodeAESZeroPadding(String data, String password, String iv) {
	try {
		byte[] decodedBytes = aesZeroPadding(
			Cipher.DECRYPT_MODE, Base64.decode(data), password, iv);
		//去除增加的zero padding
		int emptyLength = 0;
		for (int i = decodedBytes.length; i &amp;gt; 0; i--) {

			if (decodedBytes[i - 1] == 0) {
				emptyLength++;
			} else {
				break;
			}
		}
		byte[] newBytes = new byte[decodedBytes.length - emptyLength];
		System.arraycopy(decodedBytes, 0, newBytes, 0, decodedBytes.length - emptyLength);
		return StringUtils.newStringUtf8(newBytes);
	} catch (Exception e) {
		logger.error(&amp;quot;AES ZeroPadding模式解密失败&amp;quot;, e);
		throw new RuntimeException(e);
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;php参考代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;//加密
$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $privateKey, $data, MCRYPT_MODE_CBC, $iv);
echo(base64_encode($encrypted));
echo &amp;#39;&amp;lt;br/&amp;gt;&amp;#39;; 

//解密
$encryptedData = base64_decode($encrypted);
$decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $privateKey, $encryptedData, MCRYPT_MODE_CBC, $iv);
echo($decrypted);
&lt;/code&gt;&lt;/pre&gt;
	</description>
    </item>
    <item>
      <title>Maven使用常见问题</title>
      <link>http://www.vouov.com/blog/2015-03-03-maven-faq.html</link>
      <pubDate>星期二, 3 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-03-maven-faq.html</guid>
      	<description>
	&lt;ol&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;maven打包时不执行测试用例？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;有时因为测试不能运行,或者为了更快的编译,希望用mvn package的时候跳过test,有如下两种方法：&lt;br/&gt;第一种方法:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;mvn -DskipTests clean package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二种方法&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;mvn -Dmaven.test.skip=true clean package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是这两个命令是有区别的，一定要注意。参数-DskipTests和-Dmaven.test.skip=true，这两个参数的主要区别是：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;-DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。&lt;/li&gt;
    &lt;li&gt;-Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。&lt;/li&gt;
  &lt;/ul&gt;&lt;p&gt;如果在pom.xml设置了跳过，用命令即使设置跳过也不能覆盖，所以要清理掉xml中配置的&lt;code&gt;&amp;lt;skipTests&amp;gt;false&amp;lt;/skipTests&amp;gt;&lt;/code&gt;:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.10&amp;lt;/version&amp;gt;
	&amp;lt;configuration&amp;gt;
		&amp;lt;skipTests&amp;gt;false&amp;lt;/skipTests&amp;gt;
	&amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;如何手动上传打好的jar包到nexus仓库？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果想人工通过mvn命令上传已经存在的jar包到nexus上，执行maven命令如下：&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;	mvn deploy:deploy-file 
	-Durl=http://{ip}:{port}/nexus/content/repositories/{repository-id} 
	-Dfile=./target/{jar-name}.jar 
	-DrepositoryId={repository-id}  
	-DgroupId={group-id} 
	-DartifactId={artifact-id} 
	-Dversion={version} 
	-Dpackaging=jar
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;如何强制每次编译时都从仓库取最新的依赖jar包？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在执行命令时添加-U参数来强制从仓库取最新的jar包依赖，形如下面的命令：&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;mvn -U clean package
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;maven项目模块循环依赖如何解决？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于项目因为配置了循环依赖的maven工程，可以通过设定不同的artifactId来达到断掉依赖，从而保证项目能正确编译打包，就涉及到手动上传打好的jar包，并且修改artifactId上传到nexus仓库,手动上传参见第2点。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;如何同时运行package命令同时打jar和war包？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们打包的packing设置为war,并且在build阶段添加maven-jar-plugin打包插件,并且可以设置包含或者排除哪些文件, 增加如下pom.xml代码:&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
	&amp;lt;executions&amp;gt;
		&amp;lt;execution&amp;gt;
			&amp;lt;id&amp;gt;make-a-jar&amp;lt;/id&amp;gt;
			&amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
			&amp;lt;goals&amp;gt;
				&amp;lt;goal&amp;gt;jar&amp;lt;/goal&amp;gt;
			&amp;lt;/goals&amp;gt;
			&amp;lt;configuration&amp;gt;
				&amp;lt;excludes&amp;gt;
					&amp;lt;exclude&amp;gt;generatorConfig.xml&amp;lt;/exclude&amp;gt;
				&amp;lt;/excludes&amp;gt;
			&amp;lt;/configuration&amp;gt;
		&amp;lt;/execution&amp;gt;
	&amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;如何把所有依赖的jar包,输出到一个目录中？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;可以在maven的package生命周期内使用copy-dependencies复制依赖包，如下pom.xml文件内容：&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;!-- 把依赖的jar包拷到lib目录下 --&amp;gt;
&amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;
	&amp;lt;executions&amp;gt;
		&amp;lt;execution&amp;gt;
			&amp;lt;id&amp;gt;copy-dependencies&amp;lt;/id&amp;gt;
			&amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
			&amp;lt;goals&amp;gt;
				&amp;lt;goal&amp;gt;copy-dependencies&amp;lt;/goal&amp;gt;
			&amp;lt;/goals&amp;gt;
			&amp;lt;configuration&amp;gt;
				&amp;lt;outputDirectory&amp;gt;${project.build.directory}/lib&amp;lt;/outputDirectory&amp;gt;
				&amp;lt;overWriteReleases&amp;gt;false&amp;lt;/overWriteReleases&amp;gt;
				&amp;lt;overWriteSnapshots&amp;gt;false&amp;lt;/overWriteSnapshots&amp;gt;
				&amp;lt;overWriteIfNewer&amp;gt;true&amp;lt;/overWriteIfNewer&amp;gt;
			&amp;lt;/configuration&amp;gt;
		&amp;lt;/execution&amp;gt;
	&amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;如何拷贝其他目录的文件到工程中？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在maven-resources-plugin中增加资源配置目录,并且在phase配置什么时候执行拷贝动作,pom.xml添加如下代码:&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;!-- 以utf-8编码拷贝配置文件，拷贝过程中是可以做变量替换的，
也就是说你的配置文件可以是个模板，里面的${}所包含的内容是可以拷贝过程中替换的 --&amp;gt;
&amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;maven-resources-plugin&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.3&amp;lt;/version&amp;gt;
	&amp;lt;executions&amp;gt;
		&amp;lt;execution&amp;gt;
			&amp;lt;id&amp;gt;copy-resources&amp;lt;/id&amp;gt;
			&amp;lt;phase&amp;gt;compile&amp;lt;/phase&amp;gt;
			&amp;lt;goals&amp;gt;
				&amp;lt;goal&amp;gt;copy-resources&amp;lt;/goal&amp;gt;
			&amp;lt;/goals&amp;gt;
			&amp;lt;configuration&amp;gt;
				&amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
				&amp;lt;outputDirectory&amp;gt;${project.build.directory}/classes&amp;lt;/outputDirectory&amp;gt;
				&amp;lt;!-- 把配置文件拷到和jar包同一个路径下 --&amp;gt;
				&amp;lt;resources&amp;gt;
					&amp;lt;resource&amp;gt;
						&amp;lt;directory&amp;gt;assembly&amp;lt;/directory&amp;gt;
						&amp;lt;includes&amp;gt;
							&amp;lt;include&amp;gt;config/db/db.properties&amp;lt;/include&amp;gt;
							&amp;lt;include&amp;gt;log4j.properties&amp;lt;/include&amp;gt;
						&amp;lt;/includes&amp;gt;
						&amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
					&amp;lt;/resource&amp;gt;
				&amp;lt;/resources&amp;gt;
			&amp;lt;/configuration&amp;gt;
		&amp;lt;/execution&amp;gt;
	&amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;&lt;strong&gt;如何在打war是排除文件,怎么替换web.xml文件？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在打war包时可以使用packagingExcludes设置排除的文件,支持通配符. 可以通过设置webXml属性来指定打包的web.xml使用文件.具体pom.xml代码如下:&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
	&amp;lt;configuration&amp;gt;
		&amp;lt;!--&amp;lt;archiveClasses&amp;gt;true&amp;lt;/archiveClasses&amp;gt;--&amp;gt;
		&amp;lt;packagingExcludes&amp;gt;
			WEB-INF/classes/generatorConfig.xml,
			WEB-INF/classes/config/db/db.properties,
			WEB-INF/classes/**/dao/**,
			WEB-INF/classes/**/service/impl/**
		&amp;lt;/packagingExcludes&amp;gt;
		&amp;lt;webXml&amp;gt;assembly/webapp/WEB-INF/web.xml&amp;lt;/webXml&amp;gt;
	&amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
	</description>
    </item>
    <item>
      <title>对于J2EE架构以及开发流程的一些感想</title>
      <link>http://www.vouov.com/blog/2015-03-02-about-j2ee-architecture.html</link>
      <pubDate>星期一, 2 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-02-about-j2ee-architecture.html</guid>
      	<description>
	&lt;p&gt;工作好久，也接触过不同架构和框架，多少有些感触，总结一下如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;开发阶段，能够让开发人员快速上手，不能有太高的学习成本，最好是常用的Struts，spring，mybatis，hibernate等常用开源框架。提倡不要重复造轮子，最理想情况是升级改造！&lt;/li&gt;
  &lt;li&gt;开发工具能够支持代码规范的自动检查，报错。&lt;/li&gt;
  &lt;li&gt;有持续集成环境不断验证服务，必须有测试用例验证，并且验证代码是否符合规范，不符合规范报错，另外还要做代码覆盖率，注释检查等。做到错误提前发现&lt;/li&gt;
  &lt;li&gt;功能交付前要有代码review&lt;/li&gt;
  &lt;li&gt;测试以及交付阶段产生的功能需求必须跟踪&lt;/li&gt;
  &lt;li&gt;开发过程中遇到的问题和解决方案要沉淀，文档必须迭代。发挥文档应有的功能价值。&lt;/li&gt;
  &lt;li&gt;开发完成后，产品发布时自动发布成分布式或者集群式。开发不用关心如何部署。&lt;/li&gt;
  &lt;li&gt;架构要支持HA，支持故障迁移，支持动态可伸缩&lt;/li&gt;
  &lt;li&gt;产品交付阶段能够实时了解运行情况，监视实时动态，包含服务健康以及服务负载等指标，最好是图形化展示&lt;/li&gt;
  &lt;li&gt;对于不同的项目一定要有协同看板，让团队知道团队的总体目标，让团队成员明确自己的任务，一个任务要具体人员，以及交付时间，以及交付产物有哪些!并且这些产物都是可以验证和review的。在一个固定的周期内要评审回顾。建议以敏捷的方式操作&lt;/li&gt;
  &lt;li&gt;对于项目或者产品研发一定要明确不同角色的具体的流程，流程一定要管控死，流程可以根据迭代情况不断调整，但是调整前必须严格执行。否则就会有破窗效应，影响后续计划的执行，降低流程的执行效率。对于流程中的问题一定要及时弥补和反应，否则也会引起不好的后果。&lt;/li&gt;
  &lt;li&gt;测试要自动化，部署自动化，运维要自动化，尽量减少人工干预，人可以在所有流程环节中，可以设置为最不可信任节点，有可以机器代替的尽量机器执行，做到高度自动化，高度可靠，高度量化！&lt;/li&gt;
&lt;/ul&gt;
	</description>
    </item>
    <item>
      <title>穹顶之下 同呼吸共命运</title>
      <link>http://www.vouov.com/blog/2015-03-01-caijing.html</link>
      <pubDate>星期日, 1 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-01-caijing.html</guid>
      	<description>
	&lt;p&gt;今天放假，乘着小孩睡觉的时间看了“柴静雾霾调查:穹顶之下 同呼吸共命运”。感触很深，问题发生了，怎么解决才是重中之重。&lt;/p&gt;&lt;p&gt;希望我家旁边的河流流淌的不再是黑水、臭水，而是中间游着鱼儿，可以垂钓的净水。希望政府可以多做点事情，让家园更加美好，让世界更加美好！愿你我生活的世界都是美好的。&lt;/p&gt;&lt;h1&gt;发现污染记得拨打12369.这个也许是我们举手之劳。&lt;/h1&gt;&lt;p&gt;&lt;iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XOTAxMzQ1NzY0&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>怎样建立自己的Github博客</title>
      <link>http://www.vouov.com/blog/2015-03-01-how-to-create-github-blog.html</link>
      <pubDate>星期日, 1 三月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-03-01-how-to-create-github-blog.html</guid>
      	<description>
	&lt;p&gt;去年发生太多的事情，一直无时间打理博客，之前wordpress也荒废了。今年下决定好好的维护一个博客，记录一下自己的生活和学习。&lt;/p&gt;&lt;p&gt;在学习如何搭建一个github博客之前，首先我们需要了解github的博客本质是什么，我们都知道github的页面都是通过markdown语法编写的。其实github也支持普通的静态html页面显示，就类似于给你一个免费的HTML空间，你自己上传HTML页面和资源文件，这样就是一个网站，这个和我们普通理解的CMS或者Blog系统不太一样。现在Github推荐的jekyll本质就是提供一套主题给你，然后你自己运行本地的生成静态的脚本把.md结尾的文件按照模板生成静态HTML然后再发布到github的仓库中，github然后就可以对外展示你最新的东西了。所以我们的目的只有一个就是如何搭建一个静态HTML站点.&lt;/p&gt;&lt;p&gt;如何搭建一个github博客就变成如何搭建一个静态的HTML站点，那我们就不一定需要jekyll去做这件事，同样我们也可以使用纯静态HTML的空间或者PHP空间来作为我们的服务器空间。我们比较熟悉java变成，希望用自己熟悉和擅长东西来做这件事情，经过查找研究选择了&lt;a href=&quot;http://jbake.org/&quot;&gt;jbake&lt;/a&gt;来做这件事。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在操作之前我们首先要有github的账号，具体如何申请一个博客空间请参照：&lt;a href=&quot;https://help.github.com/articles/creating-pages-with-the-automatic-generator/&quot;&gt;Creating Pages with the automatic generator&lt;/a&gt;，&lt;/li&gt;
  &lt;li&gt;有了空间如何绑定域名请参照：&lt;a href=&quot;https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/&quot;&gt;Setting up a custom domain with GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样我们就有个一个github博客空间，并且可以通过域名访问了，下面就开始如何开始使用jbake搭建我们的博客系统，jbake使用freemarker模板引擎实现。具体的jbake如何运行和使用请参照：&lt;a href=&quot;http://jbake.org/docs/2.3.2/&quot;&gt;jbake使用手册&lt;/a&gt;。因为jbake不支持首页分页，我对官方源码修改了下支持首页分页，如果需要请参见我的github：https://github.com/vouov/jbake，打好的支持分页的jar包可以直接下载替换，请下载：&lt;a href=&quot;/uploads/software/jbake-core.jar&quot;&gt;jbake-core.jar&lt;/a&gt;,具体使用分页请参照我的blog源码：&lt;a href=&quot;https://github.com/vouov/blog&quot;&gt;github blog&lt;/a&gt;&lt;/p&gt;&lt;p&gt;使用jbake作为github的具体步骤如下（前提是我认为你已经申请号github博客空间，并且可以域名访问了）:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在你电脑创建一个blog目录，运行命令 jbake -i, 这样就会生成一个example博客模板，有JS、CSS、Images、freemarker模板等资源文件。&lt;/li&gt;
  &lt;li&gt;运行命令 jbake . &amp;lt;目的路径&amp;gt;, 把当前的blog内容生成静态HTML到&apos;目的路径&apos;，便于发布展示。&lt;/li&gt;
  &lt;li&gt;运行命令 jbake -s &amp;lt;目的路径&amp;gt;， 打开浏览器，输入URL地址：http://localhost:8820/,就可以看到示例博客的内容了。这个是一个bootstrap主题博客样式.&lt;/li&gt;
  &lt;li&gt;如果不喜欢官方的主题，自己可以开发。我修改后的主题可以参照我的blog源码：&lt;a href=&quot;https://github.com/vouov/blog&quot;&gt;github blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;接下来就是在blog目录中content\blog目录下写自己的.md文件，具体请参照markdown语法&lt;/li&gt;
  &lt;li&gt;写好文章就是编译成HTML，运行命令 jbake . &amp;lt;目的路径&amp;gt;,刷新一下浏览器的地址就可以看到你的文章了&lt;/li&gt;
  &lt;li&gt;提交同步自己的github仓库中，就可以通过域名访问最新的内容了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用到的软件列表如下：&lt;br/&gt;&lt;a href=&quot;http://jbake.org&quot;&gt;Jbake&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://highlightjs.org/&quot;&gt;highlightjs&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://open.weibo.com/widget/comments.php&quot;&gt;新浪微博留言箱&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://share.baidu.com/&quot;&gt;百度分享&lt;/a&gt;&lt;/p&gt;&lt;p&gt;如果使用中有什么问题可以留言给我，或者通过最底部的多种联系方式联系我！&lt;br/&gt;具体可以参照我的github blog源码：&lt;br/&gt;&lt;a href=&quot;https://github.com/vouov/blog&quot;&gt;blog jbake源码&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/vouov/vouov.github.io&quot;&gt;编译后的blog HTML&lt;/a&gt;&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Github个人博客创建</title>
      <link>http://www.vouov.com/blog/2015-02-27-github-site-create.html</link>
      <pubDate>星期五, 27 二月 2015 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2015-02-27-github-site-create.html</guid>
      	<description>
	&lt;p&gt;Github小站搞了一天终于成功。&lt;/p&gt;&lt;p&gt;后面要学会分享和笔记！记录学习的点点滴滴，记录生活的精彩！&lt;/p&gt;
	</description>
    </item>

  </channel> 
</rss>
